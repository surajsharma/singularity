- Programming `languages`, their features, readability, and interoperation
    - no room for favorites
    - support for explicitly defined data structures
    - strong static typing
    - isomorphism
        - native  eg js
        - transpiled  eg ts
        - generated eg kotlin
    
- `Code reuse` across platforms (server vs web vs mobile)

- `Early error detection` (compile-time vs runtime error detection, breadth of validation)

- Availability and cost of hiring the right talent; learning curve for new hires

- `Readability and refactorability of code`

- `Approach to code composition`, embracing the change

- `Datastore` and general approach to `data modeling`

- `Application-specific data model`, and the blast radius from changing it

- `Performance and latency` in all tiers and platforms

- `Scalability and redundancy`

- Spiky traffic patterns, autoscaling, `capacity planning`

- `Error recovery`

- Logging, `telemetry`, and other instrumentation

> Reducing complexity

> User interfaces and their maintainability

- External APIs

- User identity and `security`

- Hardware and human costs of the infrastructure and its maintenance

- Enabling multiple concurrent development workstreams

- Enabling testability

- Fast-tracking development by adopting third-party frameworks