## Chapter 4: Understanding Ownership 

- [Chapter 4: Understanding Ownership](#chapter-4-understanding-ownership)
  - [What Is Ownership?](#what-is-ownership)
    - [Ownership Rules](#ownership-rules)
    - [The String Type](#the-string-type)
    - [Memory and Allocation](#memory-and-allocation)
    - [Ownership and Functions](#ownership-and-functions)
    - [Return Values and Scope](#return-values-and-scope)
  - [References and Borrowing](#references-and-borrowing)
    - [Mutable References](#mutable-references)
    - [Dangling References](#dangling-references)
    - [The Rules of References](#the-rules-of-references)
  - [The Slice Type](#the-slice-type)
    - [String Slices](#string-slices)
    - [Other Slices](#other-slices)
  - [Summary](#summary)


### What Is Ownership? 

- [[04-memory regions]]
- stack is faster than heap, lifo 
- heap is more work than stack 

#### Ownership Rules 

1. Each value in Rust has an owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.

#### The String Type 
- But we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data, and the String type is a great example.

- We’ll concentrate on the parts of String that relate to ownership.

- String literals are convenient, but they aren’t suitable for every situation in which we may want to use text.

- One reason is that they’re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it?

- For these situations, Rust has a second string type, `String`. 

- This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a String from a string literal using the from function, like so: ```let s = String::from("hello");```

#### Memory and Allocation 

#### Ownership and Functions 

#### Return Values and Scope 

### References and Borrowing 
#### Mutable References 
#### Dangling References 
#### The Rules of References 

### The Slice Type 
#### String Slices 
#### Other Slices 

### Summary 


```rust
fn ch_4(){
	let mut str_lit = String::from("hello");
	str_lit.push_str(", world");
	
	println!("{}",str_lit);	
	
	let word = first_word(&str_lit);
	
	//str_lit.clear();
	
	println!("{}",word);
	
	fn first_word(s: &str) -> &str {
		let bytes = s.as_bytes();
		for (i, &item) in bytes.iter().enumerate() {
			if item == b' ' {
				return &s[0..i];
			}
		}		
		&s[..]
	}
}
```


[//begin]: # "Autogenerated link references for markdown compatibility"
[04-memory regions]: <../rustaceans/01-foundations/04-memory regions> "04-memory regions"
[//end]: # "Autogenerated link references"